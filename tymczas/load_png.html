<!DOCTYPE html>
<html lang="en">
<head>
    <title>DEM-Based Terrain with Dynamic Shadows</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body { margin: 0; }
        #container { width: 100%; height: 100vh; overflow: hidden; }
    </style>
</head>
<body>

    <div id="container"></div>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let container, camera, scene, renderer, terrainMesh;
        const terrainSize = { width: 256, height: 256 }; // Adjust based on DEM image size

        init();
        animate();

        function init() {
            container = document.getElementById('container');

            // Renderer setup
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;  // Enable shadows
            container.appendChild(renderer.domElement);

            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xbfd1e5);

            // Camera setup
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 10, 20000);
            camera.position.set(2000, 1500, 2000);

            // Controls setup
            const controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 250, 0);
            controls.update();

            // Load DEM PNG for height data
            const textureLoader = new THREE.TextureLoader();
            textureLoader.load('terrain_data/dem.png', (texture) => {
                const heightData = getHeightData(texture.image);
                createTerrain(heightData);
            });

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x555555);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(1000, 2000, 1000);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 5000;
            scene.add(directionalLight);

            window.addEventListener('resize', onWindowResize);
        }

        // Parse height data from DEM PNG
        function getHeightData(image) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            const { width, height } = image;
            canvas.width = width;
            canvas.height = height;
            context.drawImage(image, 0, 0);

            const imageData = context.getImageData(0, 0, width, height);
            const data = imageData.data;
            const heightArray = new Float32Array(width * height);

            for (let i = 0; i < data.length; i += 4) {
                const pixelIndex = i / 4;
                const r = data[i];       // Assuming grayscale height (only red channel is used)
                heightArray[pixelIndex] = r / 255 * 100; // Scale to adjust terrain height
            }
            return { data: heightArray, width, height };
        }

        // Create terrain from height data
        function createTerrain(heightData) {
            const geometry = new THREE.PlaneGeometry(7500, 7500, terrainSize.width - 1, terrainSize.height - 1);
            geometry.rotateX(-Math.PI / 2);

            // Apply height data to geometry vertices
            const vertices = geometry.attributes.position.array;
            for (let i = 0; i < vertices.length; i += 3) {
                const x = i / 3 % terrainSize.width;
                const y = Math.floor(i / 3 / terrainSize.width);
                const height = heightData.data[x + y * terrainSize.width];
                vertices[i + 1] = height; // Set Y position based on height data
            }
            geometry.computeVertexNormals(); // Improve shading

            // Material and mesh
            const material = new THREE.MeshStandardMaterial({
                color: 0x556b2f,
                side: THREE.DoubleSide,
            });
            terrainMesh = new THREE.Mesh(geometry, material);
            terrainMesh.receiveShadow = true;
            scene.add(terrainMesh);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
